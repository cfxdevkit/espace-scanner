import { OpenAPIV3 } from "openapi-types";
import { parseOpenApiSpec, generateTypeDefinitions, ApiEndpointInfo } from "./openapi-parser";
import { evmApi } from "./evmapi";
import * as fs from "fs";
import * as path from "path";

// Convert path to camelCase type name
function pathToTypeName(path: string, method: string): string {
  // Split path and query
  const [basePath, query] = path.split("?");

  // Get the last two parts of the path
  const pathParts = basePath.split("/").filter((p) => p);
  const lastTwoParts = pathParts.slice(-2);

  // Process the last two parts
  const baseTypeName = lastTwoParts
    .map((part) => part.replace(/[^a-zA-Z0-9]/g, ""))
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");

  // Add method to ensure uniqueness
  const methodName = method.toLowerCase();
  const typeName =
    methodName === "get"
      ? baseTypeName
      : `${baseTypeName}${method.charAt(0).toUpperCase() + method.slice(1).toLowerCase()}`;

  // Process query parameters if they exist
  if (query) {
    const queryParts = query.split("&").map((param) => {
      const [key, value] = param.split("=");
      // Convert key=value to KeyValue format
      const cleanedKey = key.replace(/[^a-zA-Z0-9]/g, "");
      const cleanedValue = value ? value.replace(/[^a-zA-Z0-9]/g, "") : "";
      return (
        cleanedKey.charAt(0).toUpperCase() +
        cleanedKey.slice(1) +
        (cleanedValue ? cleanedValue.charAt(0).toUpperCase() + cleanedValue.slice(1) : "")
      );
    });

    // Combine base name and query parts
    return typeName + queryParts.join("");
  }

  return typeName;
}

// Example OpenAPI spec
const spec: OpenAPIV3.Document = evmApi;

// Parse all endpoints
const endpointMap = parseOpenApiSpec(spec);

// Create base types that will be imported by all files
const baseTypes = `// This file is auto-generated from the OpenAPI specification
// Do not edit this file manually

/** Generic API Response type */
export interface ApiResponse<T> {
  /** Response status */
  status?: string;
  
  /** Response message */
  message?: string;
  
  /** API response result */
  result?: T;
}
`;

// Group endpoints by tags
const groupedEndpoints = new Map<string, Map<string, ApiEndpointInfo[]>>();

// Process each endpoint and group by tags
for (const [path, endpoints] of endpointMap) {
  for (const endpoint of endpoints) {
    const tags = endpoint.tags.length > 0 ? endpoint.tags : ["misc"];

    // Add endpoint to each of its tags
    for (const tag of tags) {
      if (!groupedEndpoints.has(tag)) {
        groupedEndpoints.set(tag, new Map());
      }
      const tagEndpoints = groupedEndpoints.get(tag)!;

      if (!tagEndpoints.has(path)) {
        tagEndpoints.set(path, []);
      }
      tagEndpoints.get(path)!.push(endpoint);
    }
  }
}

// Create output directory
const baseOutputDir = path.join(__dirname, "..", "src", "types", "generated");
fs.mkdirSync(baseOutputDir, { recursive: true });

// Write base types
fs.writeFileSync(path.join(baseOutputDir, "base.ts"), baseTypes);

// Generate index file to re-export everything
let indexContent = `// This file is auto-generated
export * from './base';\n`;

// Process each tag group
for (const [tag, endpoints] of groupedEndpoints) {
  // Convert tag to a valid filename (lowercase, replace spaces with hyphens)
  const fileName = tag.toLowerCase().replace(/\s+/g, "-");

  let typeDefinitions = `// This file is auto-generated from the OpenAPI specification
// Do not edit this file manually

import { ApiResponse } from './base';\n\n`;

  // Process each endpoint in the tag group
  for (const [path, endpointList] of endpoints) {
    typeDefinitions += `// Types for ${path}\n`;
    for (const endpoint of endpointList) {
      const typeName = pathToTypeName(path, endpoint.method);
      typeDefinitions += generateTypeDefinitions(endpoint, spec, typeName) + "\n";
    }
    typeDefinitions += "\n";
  }

  // Write tag file
  const outputFileName = `${fileName}.ts`;
  fs.writeFileSync(path.join(baseOutputDir, outputFileName), typeDefinitions);

  // Add to index
  indexContent += `export * from './${fileName}';\n`;
}

// Write index file
fs.writeFileSync(path.join(baseOutputDir, "index.ts"), indexContent);

console.log(`Generated type definitions written to ${baseOutputDir}`);
